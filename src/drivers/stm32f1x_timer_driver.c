#include "stm32f1x_timer_driver.h"

/* ARPE: Auto-reload preload enable
0: TIMx_ARR register is not buffered.
1: TIMx_ARR register is buffered. */
#define ARPE_NOT_BUFFER 0x00
#define ARPE_BUFFERED 0x01

/* OPM: One-pulse mode
0: Counter is not stopped at update event
1: Counter stops counting at the next update event (clearing the CEN bit). */
#define OPM_CNT_NOT_STOP 0x00
#define OPM_CNT_STOP 0x01

/* URS: Update request source
This bit is set and cleared by software to select the UEV event sources.
0: Any of the following events generates an update interrupt or DMA request if enabled.
These events can be:
– Counter overflow/underflow
– Setting the UG bit
– Update generation through the slave mode controller
1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled */
#define URS_ANY_EVENTS 0x00
#define URS_ONLY_CNT_OVERFLOW 0x01

/* UDIS: Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
0: UEV enabled. The Update (UEV) event is generated by one of the following events:
– Counter overflow/underflow
– Setting the UG bit
– Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.
1: UEV disabled. The Update event is not generated, shadow registers keep their value
(ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if
a hardware reset is received from the slave mode controller. */
#define UDIS_ENABLE 0x00
#define UDIS_DISABLE 0x01

/* CEN: Counter enable
0: Counter disabled
1: Counter enabled */
#define CEN_DISABLE 0x00
#define CEN_ENABLE 0x01

/* MMS[2:0]: Master mode selection
These bits are used to select the information to be sent in master mode to slave timers for
synchronization (TRGO). The combination is as follows:
000: Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If
reset is generated by the trigger input (slave mode controller configured in reset mode) then
the signal on TRGO is delayed compared to the actual reset.
001: Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is
useful to start several timers at the same time or to control a window in which a slave timer
is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit
and the trigger input when configured in gated mode.
When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO,
except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR
register).
010: Update - The update event is selected as a trigger output (TRGO). For instance a
master timer can then be used as a prescaler for a slave timer. */
#define MSS_RESET 0x00
#define MSS_ENABLE 0x01
#define MSS_UPDATE 0x02

/* UDE: Update DMA request enable
0: Update DMA request disabled.
1: Update DMA request enabled. */
#define UDE_DMA_ENABLE 0x01
#define UDE_DMA_DSIABLE 0x00

/* UIE: Update interrupt enable
0: Update interrupt disabled.
1: Update interrupt enabled. */
#define UIE_INTERRUPT_ENABLE 0x01
#define UIE_INTERRUPT_DSIABLE 0x00

/* UIF: Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
0: No update occurred.
1: Update interrupt pending. This bit is set by hardware when the registers are updated:
– At overflow or underflow and if UDIS = 0 in the TIMx_CR1 register.
– When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0
and UDIS = 0 in the TIMx_CR1 register. */
#define UIF_NO_UPDATE 0x00
#define UIF_UPDATE_PENDING 0x01

/* UG: Update generation
This bit can be set by software, it is automatically cleared by hardware.
0: No action.
1: Re-initializes the timer counter and generates an update of the registers. Note that the
prescaler counter is cleared too (but the prescaler ratio is not affected). */
#define UG_NO_ACTION 0x00
#define UG_REINITIALIZE_CNT 0x01

/* PSC[15:0]: Prescaler value
The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event
(including when the counter is cleared through UG bit of TIMx_EGR register or through
trigger controller when configured in “reset mode”). */
#define PSC_VALUE 9 /* 72Mhz / 10 = 720Khz */

/* ARR[15:0]: Auto-reload value
ARR is the value to be loaded into the actual auto-reload register.
Refer to Section 17.3.1: Time-base unit for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null. */
#define ARR_VALUE 7200 /* Generate clock each 1ns */

#define TIME1_BASE_ADDRESS (ADV_TIM_REG_MAP *)0x40012C00
#define TIME2_BASE_ADDRESS (ADV_TIM_REG_MAP *)0x40000000
#define TIME3_BASE_ADDRESS (ADV_TIM_REG_MAP *)0x40000400
#define TIME4_BASE_ADDRESS (ADV_TIM_REG_MAP *)0x40000800
#define TIME5_BASE_ADDRESS (ADV_TIM_REG_MAP *)0x40000C00
#define TIME6_BASE_ADDRESS (BASIC_TIM_REG_MAP *)0x40001000
#define TIME7_BASE_ADDRESS (BASIC_TIM_REG_MAP *)0x40001400
#define TIME8_BASE_ADDRESS (ADV_TIM_REG_MAP *)0x40013400

// static volatile ADV_TIM_REG_MAP *const stm32f1x_reg_tim1 = TIME1_BASE_ADDRESS;
// static volatile ADV_TIM_REG_MAP *const stm32f1x_reg_tim8 = TIME8_BASE_ADDRESS;
static volatile BASIC_TIM_REG_MAP *const stm32f1x_reg_tim6 = TIME6_BASE_ADDRESS;

static volatile DWORD stm32f1x_tim6_counter = 0;

void stm32f1x_timer_driver_init()
{
    stm32f1x_reg_tim6->CR1.ARPE = ARPE_BUFFERED;
    stm32f1x_reg_tim6->CR1.OPM = OPM_CNT_NOT_STOP;
    stm32f1x_reg_tim6->CR1.UDIS = UDIS_ENABLE;
    stm32f1x_reg_tim6->CR1.URS = URS_ONLY_CNT_OVERFLOW;

    stm32f1x_reg_tim6->CR2.MMS = MSS_RESET;

    stm32f1x_reg_tim6->DIER.UDE = UDE_DMA_DSIABLE;
    stm32f1x_reg_tim6->DIER.UIE = UIE_INTERRUPT_ENABLE;

    stm32f1x_reg_tim6->EGR.UG = UG_NO_ACTION;

    stm32f1x_reg_tim6->PSC.PSC = PSC_VALUE;
    stm32f1x_reg_tim6->ARR.ARR = ARR_VALUE;
    stm32f1x_reg_tim6->CR1.CEN = CEN_ENABLE;
}

void TIM6IRQ_Handler()
{
    /* Clear interrupt flag */
    stm32f1x_reg_tim6->SR.UIF = UIF_NO_UPDATE;
}
